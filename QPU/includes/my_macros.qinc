#############################################################
# Most macros copied from vc4-samples/hello_fft.
#############################################################

.macro exit, flag
	#mov interrupt, flag # mov problematic?!
	or rb38, ra39, flag  # No, it seems that we must read ra39
	nop; nop; thrend
	nop 
	nop 
.endm

#############################################################

# x = y; y = x
.macro swap_buffer, a, b
    mov a, b; mov b, a
.endm

#############################################################

# Shortcut for branching with three nop's.
.macro proc, rx_ptr, label
    brr rx_ptr, label
    nop
    nop
    nop
.endm

#############################################################
## Variable VPM write setup
#
# To write at different positions this macro evaluate for
# a given QPU id the correct position for writing data into
# the VPM. Moreover, the VPM is split into two distinct areas.
# 
# in_inst - QPU id
#  i - Index of long vector of 16-tuples (of quads).
# qi = q_i = 16 quads (= 16* 4 bytes) at position i
# out_0   - Start cmd for first halve
# out_1   - Start cmd for second halve
#
.macro vpm_qsetup_h_a, in_num_inst, in_inst, out_0, out_1
    # Difference in r1 required to set write stride on each QPU.
    # Difference in r2 is required to set start point for each QPU.
    #mov out_0, vpm_setup(1, 1, h32( 0,0))
    mov r0, vpm_setup(1, 1, h32( 0,0))
    mov r1, vpm_setup(1, 2, h32(0,0)) - vpm_setup(1, 1, h32(0,0))
    mov r2, vpm_setup(1, 1, h32(1,0)) - vpm_setup(1, 1, h32(0,0))
    
    # We need 'r0 + (N-1)*r1 + n*r2'. Backup r1 in out_0
    # to substract it after 'r0+N*r1+n*r2' operation
    mov out_0, r1; mul24 r1, r1, in_num_inst
    nop; mul24 r2, r2, in_inst
    add r1, r1, r2
    sub r1, r1, out_0

    mov out_1, vpm_setup(1, 1, h32(32,0))
    add out_0, r0, r1
    add out_1, out_1, r1
.endm                                                                                    

#############################################################
## Variable VDM write setup (matches to vpm_qsetup_h_a)
#
# Setup to write in both rounds 
# r * number_of_used_QPUs * 16 words.
# r is the number of registers, each used QPU is set per round.
#
# Note: Stride setup is not contained here
#       ( mov vw_setup, vdw_setup_1(0) ).
.macro vdm_qsetup_h_a, in_num_inst, const_r, out_0, out_1
	mov r0, vdw_setup_0(1, 16, dma_h32(0, 0))
	mov r1, vdw_setup_0(1, 16, dma_h32(32, 0))
	mov r2, vdw_setup_0(const_r, 16, dma_h32(0, 0)) - vdw_setup_0(1, 16, dma_h32(0, 0))

	mul24 r2, r2, in_num_inst
	add out_0, r0, r2
	add out_1, r1, r2
	mov out_0, vdw_setup_0(1, 16, dma_h32(0, 0))
	mov out_1, vdw_setup_0(1, 16, dma_h32(32, 0))
.endm                                                                                    

#############################################################
## Generate and collect VPM setups in single register.
#
# Assume split of required VPM space into two halves, N QPUs and
# K writes into VPM of each QPU. Moreover it holds K*N <= 32 
# (=> no overlap of halves)
#
# This macro retuns the setup values for the first and second
# halve in r_out.P_h, h=0,1.
# 
# After setup with r_out.P_h, QPU i writes into VPM register(s).
# h*K*N + i + 0*N, ..., h*K*N + i + (K-1)*N  (=> stride is N)
#
# Note: Use rotate command for setup, i.e.
#       mov vw_setup, ra_tmp1 << P_0
#
.macro vpm_setup_halve, in_num_inst, in_inst, K, r_out, P_0, P_1
    # D1 is required to set write stride (N) on each QPU.
    # D2 is required to set start point for each QPU.
    mov r0, vpm_setup(1, 1, h32(0,0))                             # S
    mov r1, vpm_setup(1, 2, h32(0,0)) - vpm_setup(1, 1, h32(0,0)) # D1
    mov r2, vpm_setup(1, 1, h32(1,0)) - vpm_setup(1, 1, h32(0,0)) # D2
    
    # We need 'S + (N-1)*D1 + in_inst*D2'.
		# Following lines evaluate 'S + (N-0)*D1 + in_inst*D2'
		# and finally substract r1 (which was backuped in r3).
    mov r3, r1; mul24 r1, r1, in_num_inst
    nop; mul24 r2, r2, in_inst
    add r1, r1, r2
    sub r1, r1, r3;
		# Now, r0+r1 is setup for position (0*K*4 + i, 0) and stride N

		# Shift of second halve (<= 32),
		mul24 r2, r2, K
		# Now, r2 stores diff 'h32(K*in_num_inst,0)-h32(0,0)'

    # Save values in out[P_i]
		sub.setf -, elem_num, P_0
    add.ifz r_out, r0, r1

		add r2, r0, r2
		sub.setf -, elem_num, P_1
    add.ifz r_out, r2, r1
.endm                                                                                    

#############################################################
## Variable VDM write setup (matches to vpm_setup_halve)
#
# Setup to write 'K * number_of_used_QPUs * 16 words'
# in both rounds.
# K is the number of registers, each used QPU fills per round.
# VPM start point of round h: h*K*N, h=0,1
#
# Note: Required stride setup will be
#       mov vw_setup, vdw_setup_1(0)
#
.macro vdm_setup_halve, in_num_inst, K, r_out, P_0, P_1
	mov r0, vdw_setup_0(1, 16, dma_h32(0, 0))                                      # S
	mov r1, vdw_setup_0(2, 16, dma_h32(0, 0)) - vdw_setup_0(1, 16, dma_h32(0, 0))  # D1
	mov r2, vdw_setup_0(1, 16, dma_h32(1, 0)) - vdw_setup_0(1, 16, dma_h32(0, 0))  # D2

	# O1 = S + (N*K-1) * D1 is the setup to write N*K register, starting at (0,0)
	# O2 = O1 + (N*K) * D2  is the setup to write N*K register, starting at (N*K,0)
	## O3 same as O1 but length 'rb_M % (N*K)'
	## O4 same as O2 but length 'rb_M % (N*K)'

	# Evaluate S + N*K*D1 and substract D1
  ; mul r5, in_num_inst, K  # N*K
	nop
	mul24 r3, r5, r1          # N*K*D1
	mul24 r2, r5, r2          # N*K*D2
	nop
	sub r3, r3, r1						# O1 - r0
	add r2, r3, r2            # O2 - r0


	# Save values in r_out[P_i]
	sub.setf -, elem_num, P_0
	add.ifz r_out, r0, r1

	sub.setf -, elem_num, P_1
	add.ifz r_out, r2, r0
.endm                                                                                    

#############################################################
## Variable VDM write setup (matches to vpm_setup_halve)
#
# Setup to write 'min(L, K * N) * 16 words'
# where L is the number of unhandled input vectors,
# K is the number of registers, each used QPU fills per round, 
# and N is the number of used QPUs.
# 
# It return two values, one for an start at (0,0) of the VPM
# and one for a start at (K*N, 0).
#
# Call this setup after number or available registers falls under
# N*K.
#
.macro vdm_setup_halve_last, in_num_inst, K, r_out, P_0, P_1
	mov r0, vdw_setup_0(1, 16, dma_h32(0, 0))                                      # S
	mov r1, vdw_setup_0(2, 16, dma_h32(0, 0)) - vdw_setup_0(1, 16, dma_h32(0, 0))  # D1
	mov r2, vdw_setup_0(1, 16, dma_h32(1, 0)) - vdw_setup_0(1, 16, dma_h32(0, 0))  # D2

	# O1 = S + (N*K-1) * D1 is the setup to write N*K register, starting at (0,0)
	# O2 = O1 + (N*K) * D2  is the setup to write N*K register, starting at (N*K,0)
	## O3 same as O1 but length 'rb_M % (N*K)'
	## O4 same as O2 but length 'rb_M % (N*K)'

	# Evaluate S + N*K*D1 and substract D1
  ; mul r5, in_num_inst, K  # N*K
	nop
	mul24 r3, r5, r1          # N*K*D1
	mul24 r2, r5, r2          # N*K*D2
	nop
	sub r3, r3, r1						# O1 - r0
	add r2, r3, r2            # O2 - r0


	# Save values in r_out[P_i]
	sub.setf -, elem_num, P_0
	add.ifz r_out, r0, r1

	sub.setf -, elem_num, P_1
	add.ifz r_out, r2, r0
.endm                                                                                    

  
#############################################################
## Wait till DMA write is finished
.macro dma_wait
	#or rb39, rb50, ra39
  read vw_wait
.endm                                                                                    

#############################################################
## Get offset between label (=line number during compilation)
# and absolute branching address for same instruction.
#
# Requires modded vc4asm, https://github.com/YggdrasiI/vc4asm
# and is disabled as default. Define LDI_LABELS to enable.
# macro
#.set LDI_LABELS, 1

.macro get_address_label_offset, out
  .if LDI_LABELS > 0
    ldi out, r:1f     # Label index of following :1
    brr r0, r:1f      # r0 holds absolute instruction address
    nop 
    nop
    nop

    :1                # PC+4
    sub out, r0, out  # Offset of both
  .endif
.endm

## Use above offset to gen brach targets
.macro load_address, out, labelname, offset
  .if LDI_LABELS > 0
    ldi r0, labelname
    add out, r0, offset
  .endif
.endm



#############################################################
#############################################################
